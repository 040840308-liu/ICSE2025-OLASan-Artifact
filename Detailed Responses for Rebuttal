
1.	Details about Practical use scenarios
    
    OLASan is primarily designed for pre-production environments where performance matters during testing and debugging phases, 
and where profiling can be leveraged. In these scenarios, OLASan’s dynamic profiling helps reduce runtime overhead by optimizing checks 
based on previously observed access patterns.  To clarify, dynamic profiling in OLASan is on-demand and primarily designed to reduce the 
runtime overhead by optimizing checks for hot program paths. 

    OLASan can complement existing fuzzing tools by sanitizing uncovered code paths with default strategies, while offering reduced 
overhead for pre-profiled sections.

2.	Details about Dynamic Profiling in OLASan
    
    Dynamic profiling is a key component in OLASan, designed to handle scenarios where static analysis alone is insufficient, 
particularly in complex memory access patterns. It helps in identifying runtime behaviors that static techniques might miss, ensuring 
more accurate and optimized sanitization.

    Purpose: The primary goal of dynamic profiling is to capture and analyze memory access patterns during program execution, especially
when pointer aliasing or arithmetic is involved. Static analysis can determine memory access offsets in many cases, but it struggles 
with dynamic behaviors, such as when pointers reference overlapping memory regions or when offsets depend on input data. Dynamic 
profiling allows OLASan to track these memory accesses during runtime, collecting real-time data about object base addresses and offsets.
This data is then used to aggregate memory accesses and reduce the number of sanitization checks needed during execution.
    
    Technical Details:
    (1) Instrumentation of Memory Accesses: OLASan instruments the GEP (getelementptr) instructions in LLVM IR, which are used to 
compute memory addresses. A logging mechanism is inserted to record base pointer addresses after each memory access. This allows OLASan 
to accurately identify the base address of objects during execution, which can be difficult to determine statically.
    (2) Handling Complex Pointer Arithmetic: Dynamic profiling is especially useful in cases where the base address of a pointer is 
altered during execution. Even if the indices in a GEP instruction are constant, the base address might change due to pointer arithmetic
or aliasing, making it hard to infer the true object base statically. Profiling allows OLASan to retrieve this information in real-time.
    (3) Custom Heap Allocator: OLASan uses a custom heap allocator that embeds size-class information in the high bits of pointers. 
This enables the system to retrieve the object base address efficiently and calculate the correct offsets for memory accesses during 
runtime. This allocator also ensures accurate tagging and detection of buffer overflows and underflows by employing deterministic tag 
assignment and spatial guards around objects.

    By using dynamic profiling, OLASan is able to optimize checks for frequently accessed memory regions and avoid redundant 
instrumentation, improving performance. For code paths not covered by the profiling, OLASan reverts to its default sanitization 
strategy, ensuring full coverage and memory safety.

3.	Clarification on the Domination-Based Grouping Algorithm
    
    The domination-based grouping algorithm is a critical component of OLASan's memory access aggregation strategy, aimed at optimizing 
the sanitization process for memory accesses to the same object. This algorithm enhances efficiency by minimizing the number of runtime 
checks required while ensuring memory safety.

    Algorithm Overview
    1.	Initialization and Access Aggregation: The algorithm begins with the initialization of memory access records, where offsets for 
each memory access are collected through dynamic profiling. This profiling phase captures real-time memory access patterns during 
program execution, allowing OLASan to accurately determine which memory accesses pertain to the same object base. Each entry in the 
resulting dictionary corresponds to a unique object base address, with its value being a set of memory accesses related to that base. 
This step is crucial for establishing accurate relationships among memory accesses, facilitating subsequent analysis.
    2.	Dominance Analysis: After aggregating memory accesses, the algorithm performs a dominance analysis on the aggregated accesses 
for each object. Using LLVM's built-in Dominance Analysis, it identifies which memory accesses dominate others, enabling safe grouping. 
If one memory access can be said to dominate another, they may be safely combined in the sanitization process.
    3.	Memory Access Grouping: Following the dominance analysis, the algorithm processes each group of memory accesses. It sorts these 
accesses based on their offsets (gathered from the dynamic profiling phase) and selects only the maximum and minimum offsets for 
sanitization. This means that rather than instrumenting every individual access, OLASan checks only the extremes, ensuring coverage 
across the full range of accesses. For groups containing two or fewer accesses, all accesses in that group are sanitized directly.
    
    Handling Control Flow and Edge Cases
    The concern regarding potential false negatives when memory accesses from different control flow paths are grouped is valid. In 
scenarios where different execution paths access the same memory object at varying offsets, it is essential to instrument all relevant 
accesses correctly.
    To mitigate this risk, OLASan retains checks for accesses from all branches if dynamic profiling indicates they point to the same 
object. The algorithm will include only one representative access in the grouped sanitization process while ensuring that other 
accesses are instrumented as a fallback. This dual approach minimizes the chance of overlooking unsafe memory accesses.

4.	Details about Loop-Oriented Access Sanitization
    
    One of the major performance challenges in memory sanitization arises from loops, where memory accesses are repeated across 
iterations. OLASan’s loop-oriented access sanitization is designed to minimize the performance overhead caused by repeated checks in 
such loops, without compromising on detection accuracy.

    Purpose: In loops where memory accesses follow predictable patterns, such as array indexing, it is inefficient to instrument every 
memory access in every iteration. Instead, OLASan checks the memory accesses at the boundaries of the loop (i.e., the first and last 
iterations). This reduces the number of runtime checks while ensuring that the entire range of memory accessed within the loop is 
properly monitored.

    Technical Details:
    (1) Monotonic Loop Accesses: For loops where memory is accessed in a monotonic or predictable fashion, such as arrays or contiguous 
memory regions, OLASan identifies the bounds of the memory accesses. It instruments only the first and last access points in the loop,
ensuring that all intermediate accesses are implicitly checked. This optimization reduces the overhead of sanitizing each individual 
iteration of the loop, as would be done in traditional sanitizers.
    (2) Dynamic Profiling and Static Domination Analysis for Loop Optimization: Dynamic profiling and static domination analysis
complement loop-oriented sanitization by identifying loops where multiple memory accesses target the same object. When such patterns
are detected, OLASan can group these accesses and apply boundary checks at the loop level, rather than at every iteration. This 
approach is especially beneficial in loops with large numbers of iterations, as it minimizes the number of checks while maintaining 
accuracy.
    (3) Fallback for Non-Monotonic Loops: In cases where the memory access pattern is not predictable (e.g., when iterating over 
non-contiguous memory structures like linked lists), OLASan reverts to its default sanitization strategy. This ensures that memory 
safety is not compromised even when the optimization cannot be applied.

5.	Details about Libc-Checking in OLASan
    
    The libc-checking mechanism in OLASan is an optimization strategy designed to handle memory accesses via standard library functions
(e.g., memcpy) efficiently, without incurring excessive overhead from redundant checks. In many sanitizers, library functions are 
treated as black boxes, leading to fine-grained checks that can significantly slow down execution. OLASan addresses this by introducing 
customized shadow checks that are tailored to the specific memory access patterns of libc functions.

    Purpose: Traditional sanitizers insert checks at fixed intervals (e.g., every 8 bytes) during large memory operations such as 
memcpy. This approach, while thorough, is often unnecessary and leads to significant performance penalties. OLASan mitigates this by 
leveraging the size of the object being copied or manipulated and performing checks only at key points, thus optimizing the 
sanitization of library calls.

    Technical Details:
    (1) Customized Shadow Memory: OLASan embeds the object’s class size into the higher bits of pointers using a custom memory tagging 
approach. This allows the sanitizer to retrieve the class size of an object during runtime and perform targeted checks without needing 
to instrument every byte of memory.
    (2) Boundary Checks: For a memcpy operation, instead of checking every small chunk of memory, OLASan only checks the start and end 
of the memory block being accessed. If the memory size exceeds the class size embedded in the pointer, an error is flagged. Otherwise, 
the start and end of the memory operation are verified, minimizing performance impact while maintaining safety.
    Example: In a memcpy operation copying 3960 bytes, OLASan first extracts the class size from the high bits of the pointer and 
compares it to the memory operation length. If the object is large enough to accommodate the operation, only the first and last memory 
access are checked, reducing the number of checks from hundreds to just two.

6.	Details about Distinctive Loop Patterns in SPEC 2006
    
    SPEC 2006 includes several test cases that feature non-monotonic loop-based memory access patterns, which are particularly 
challenging for OLASan to optimize. These loops differ from the more straightforward patterns found in SPEC 2017. For example, in 
SPEC 2006 benchmarks such as 456.hmmer and 450.soplex, the memory accesses within loops involve complex, irregular iteration patterns. 
These patterns often depend on data-dependent conditions, non-contiguous memory accesses, and pointer arithmetic, which create 
difficulties in applying OLASan's loop-oriented access sanitization strategy.
    
     Why OLASan Faces Optimization Challenges with These Patterns?
     OLASan is designed to optimize memory checks within monotonic loops—loops where the memory access pattern is predictable and 
linear, such as when accessing contiguous array elements. For such loops, OLASan checks only the start and end memory access in the 
loop, reducing overhead significantly. However, in non-monotonic loops, where memory access patterns change unpredictably across
iterations, OLASan cannot reliably apply these optimizations without risking missed checks. This forces OLASan to revert to the default,
more comprehensive instrumentation, which incurs higher overhead.

     For example, 456.hmmer involves loops where pointer references are frequently adjusted within the loop body, leading to indirect 
memory accesses that are not aligned sequentially. 450.soplex includes loops where memory operations involve reallocating and
reorganizing data structures in ways that are difficult to track using OLASan’s typical optimizations. These irregular memory access 
patterns necessitate full memory access checks on each iteration of the loop, which increases the performance overhead.

     By contrast, SPEC 2017 features benchmarks that generally exhibit more predictable memory access patterns, making them more 
amenable to OLASan’s optimizations. For instance, benchmarks like 508.namd_r and 531.deepsjeng_r involve more straightforward 
array-based loops where memory accesses follow linear or monotonic sequences. OLASan's ability to apply loop-oriented sanitization 
in these cases leads to lower overhead in SPEC 2017 compared to SPEC 2006.

7.	Details about Conceptual Comparison with Existing Methods

    OLASan brings several innovative improvements over existing sanitizers like ASan, HWASan, and others. The following comparison
highlights OLASan’s key contributions and contrasts it with the limitations of other state-of-the-art sanitization techniques.

    OLASan focuses on object-level memory access, which enables it to aggregate multiple memory accesses within the same object 
into a single check. This contrasts with existing sanitizers such as ASan and HWASan, which perform checks at the byte or block 
level, leading to more frequent checks and higher overhead.

    This aggregation allows OLASan to efficiently handle complex access patterns, including intra-object overflows, which many 
traditional sanitizers miss. For example, ASan relies heavily on shadow memory and often fails to detect intra-object overflows, 
where an overflow occurs between fields of a struct. OLASan’s approach provides better protection by checking entire objects rather 
than just individual memory blocks.

    OLASan significantly reduces false negatives compared to other sanitizers. HWASan, which uses hardware-assisted memory tagging,
relies on probabilistic memory safety checks due to its use of random tags. This method introduces a chance of tag collisions,
leading to potential undetected errors. In contrast, OLASan’s deterministic memory tagging ensures that object-level boundaries are
clearly defined, eliminating the risk of such collisions.

    Additionally, many sanitizers (e.g., ASan) do not fully instrument library functions, which can lead to missed memory violations,
especially in complex real-world programs. OLASan, through its customized shadow checks for libc functions, addresses this gap and 
ensures that critical operations like memcpy are safely monitored.
